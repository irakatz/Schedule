0 一些基础的事情
0.1 CPU，指令集，Linux的关系
CPU有自己独特的指令集。Linux可以在不同CPU下编译成不同的版本，适应相应的指令集。
项目用的是risc-v指令集，应该是用相应编译器把rust语言翻译成这种指令集。实际上rust和risc-v是两个独立概念。
0.2 这个操作系统实现了什么
创建了一个基于qemu+用rust写的OS，现有的6个Lab包含中断处理，物理内存分配与管理，页表映射（VA到PA），线程调度，设备驱动和为用户程序提供服务
uCore包括内存（VA，PA），进程，FS（虚拟FS和简单FS）。
0.3 为什么要用rust*来源自wrj论文
C会有安全问题，因为程序员可能没有管理好内存，但是如果自动管理内存，程序会因为GC暂停，GC也有开销，这不利于性能。Rust在编译期检查内存安全（使用所有权，生命周期）；使用send与sync限制跨线程传递和多线程访问，以实现线程安全。
rust可以实现基本的底层控制，但是不是太底层。rust支持面向对象，并且优化了这些抽象
另外尽量减少代码，减少造轮子。
关于引用与借用：https://zhuanlan.zhihu.com/p/59998584
1 各个Lab的实现
1.0 Lab0
这一章告诉我们如何从头开始创建rust OS。
首先这个OS需要移除标准库和运行环境依赖（举例是print），因为实际操作的OS是没有这个库的。这让我想起了Linux的printk，作用也是打印。
调整内存布局是因为程序默认开始位置和一般OS内核开始位置不一样。
另外也要重写程序入口，准确说是不使用main函数作为入口，在新的入口调用mod的init函数来初始化各个mod
最后是console和print的实现，通过QEMU的OpenSBI启动内核

1.1 Lab1
这一章是关于中断处理（exception,interrupt,trap的概念不具体说），中断后需要保存所有通用寄存器，还有CSR寄存器。一般是写汇编来保存通用寄存器，这个和Linux一样。Context结构体来保存一些CSR寄存器状态。然后要实现处理中断(handle_interrupt)，再实现恢复寄存器。
对于处理中断，需要先找到中断入口（将其写入stvec寄存器），以及写入触发中断函数。
这里实现了两个中断，断点和时钟中断，可以尝试写别的中断。另外进程切换也要触发中断

1.2 Lab2
这一章是关于动态内存分配，需要支持如Vec之类的数据结构，我们借用了Linux的buddy system来实现这个
OpenSBI扫描外设（包括物理内存），保存dtb结果，并将地址存在a1 reg中。实际上地址空间是QEMU分配的，我们只管理DRAM
管理物理内存是使用页帧(frame),每个帧开头地址除以4096（4KB）即它的物理页号。帧是连续的，接下来要实现帧的分配和回收（写一个分配器），分配器的具体算法可以自己写，这里用得是线段树，也可以用栈

1.3 Lab3
这一章是虚拟地址和物理地址的映射。
每个进程所看到的是自己的地址，这些地址是虚拟地址，OS用页表维护虚拟地址和物理地址的映射
为了实现 Sv39 页表，我们的思路是把一个分配好的物理页（即会自动销毁的 FrameTracker）拿来把数据填充作为页表，而页表中的每一项是一个 8 字节的页表项。
对于页表项，需要获得它的页号，地址，有效位等。512个连续页表项组成一个页，映射之后可以封装成页表
我们需要正确设置不同段（text，data...）的访问权限，某个段可能会占用很多页，他们需要有一个统一的属性。所以我们要先封装内存段（一段连续的页，每一页会映射到一个页帧），之后对页表和内存段进行封装（使用mapping），把所有段放入mapping并给他们一个新的名字MemorySet
发生缺页的页面置换算法略，OS已学过

1.4 Lab4
这一章是线程调度
线程创建，需要建立页表映射（映射线程代码，执行栈和部分内存空间），设置开始地址，初始化寄存器，设置一些参数。线程执行，可以修改中断，让它读取我们设置的context（包括通用寄存器，sepc,sstatus）,以在rust文件中调用。
切换线程要出发中断，保存上一个线程的context，然后将下一个线程的context恢复并返回。线程调度使用一个抽象的处理器来做，算法略
线程结束要标记自己结束，并触发一个ebreak异常，可以让操作系统得知并终止
内核栈是为了处理用户线程产生的异常，在中断时使用，我们需要把它的地址放在sscratch（仅在内核态访问，为了确保线程能找到一个可信的reg），当中断产生时，把context押入sscratch指向的栈，用这个地址替换sp,sp被复制到a0作为处理中断的参数；返回时，a0指向押在内核栈的context，出栈并把栈顶保存在sscratch内

1.5 Lab5
这一章是和设备驱动有关，OS课上没仔细学
OpenSBI扫描设备并且保存了（dtb地址在a1,HART ID在a0）,DT的节点属性略。要解析DT可以用rCore的device_tree。
让QEMU支持virtio协议来挂载虚拟存储设备，接下来要找这些设备。注意要通过MMIO把DRAM也加入到页表中，以让内核线程访问。我们使用rCore的virtio_drivers来用MMIO对设备交互，不过我们要提供一些申请物理内存，PA->VA转换等接口。
之后是写抽象驱动和块设备驱动（包括virtio-blk），利用virtio把物理设备抽象成驱动，在准备把他们给FS使用
利用rCore的rcore-fs（实际选用是simple file system）制作文件系统，可以基于INode来操作FS。

1.6 Lab6
这一章要生成ELF格式用户程序，放入文件系统并运行
解析ELF使用xmas-elf解析器，读取文件内容和解析字段，并建立MemorySet。之后修改Mapping::map。
实现用户程序的系统调用，只要传递参数即可，我们需要设置参数的解释（处理文件描述符），可以打开外部中断来接收按键信息。
处理条件变量还要再看看，这里我没有看懂。
